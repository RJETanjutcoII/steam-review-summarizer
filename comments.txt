================================================================================
STEAM REVIEW SUMMARIZER — CODE WALKTHROUGH
================================================================================

A guide to understanding every piece of this project. Read this alongside the
actual source code for the full picture.


================================================================================
PROJECT STRUCTURE
================================================================================

backend/
  app/
    main.py          → FastAPI routes + CORS middleware
    steam_scraper.py → Steam API communication
    analysis.py      → ML pipeline (embeddings, clustering, TF-IDF)
    generator.py     → LLM API calls (OpenRouter)
    summarizer.py    → Orchestrator that ties analysis + generator together

frontend/
  src/
    main.jsx         → React entry point (mounts App to the DOM)
    App.jsx          → Root component (state, API calls, layout)
    App.css          → Page-level styles
    index.css        → Global reset + CSS variables (Steam theme)
    components/
      SearchBar.jsx/.css      → Autocomplete search input + dropdown
      LoadingSpinner.jsx/.css → Animated spinner during loading
      ResultDisplay.jsx/.css  → Game banner + praised/criticized lists


================================================================================
BACKEND
================================================================================

--- main.py ---

FastAPI is a Python web framework. You define routes with decorators like
@app.get("/search"). When someone visits that URL, the function below it runs
and its return value becomes the JSON response.

Query(..., min_length=1) tells FastAPI: "this is a required query parameter,
and it must be at least 1 character." FastAPI automatically returns a 422
error if the validation fails.

CORS middleware: Browsers enforce a "same-origin policy" — JavaScript on
localhost:5173 can't make requests to localhost:8000 by default. The CORS
middleware adds HTTP headers that tell the browser "I trust this origin,
allow the request." Without it, every fetch() from the frontend would fail.


--- steam_scraper.py ---

search_games() calls the same endpoint that Steam's own website search bar
uses: steamcommunity.com/actions/SearchApps/. It returns JSON with app IDs
and names. We proxy this through our backend so the frontend doesn't need
to deal with CORS issues from Steam's servers.

get_reviews_by_id() hits Steam's review API. The key parameters:
  - json=1: return JSON instead of HTML
  - num_per_page=100: fetch 100 reviews at once
  - filter=recent: get the most recent reviews
  - language=english: only English reviews

_get_game_name() uses Steam's appdetails API to look up a game's official
name from its numeric ID. The underscore prefix (_) is a Python convention
meaning "this function is private — only used internally in this file."

requests.utils.quote() URL-encodes the query string. Spaces become %20,
special characters get escaped. Without this, URLs with spaces would break.


--- analysis.py ---

This is the ML (machine learning) core. Here's what each piece does:

SentenceTransformer('all-MiniLM-L6-v2'):
  A pre-trained neural network that converts sentences into 384-dimensional
  vectors (arrays of 384 numbers). Sentences with similar meaning end up
  with similar vectors. "Great combat system" and "Fighting feels amazing"
  would have vectors pointing in roughly the same direction, even though
  they share no words. This is called "semantic similarity."

  The model is loaded once at startup (line 16) because loading it takes
  a few seconds. After that, encoding sentences is fast.

_clean_text():
  Steam reviews contain HTML tags (<br>), BBCode ([b]bold[/b]), and messy
  whitespace. This strips all of that down to plain text.

_is_english():
  Counts ASCII letters vs total letters. If less than 80% are ASCII, it's
  probably not English (Russian, Chinese, etc.). Steam's language filter
  isn't perfect, so this catches what slips through.

_is_opinion_sentence():
  Filters out personal anecdotes ("I remember playing this as a kid") and
  keeps sentences that actually discuss the game. It checks for the presence
  of game-related words (gameplay, graphics, combat, etc.).

extract_sentences():
  The full preprocessing pipeline: clean → check English → censor profanity
  → split into sentences → filter by length → filter by opinion content.
  The profanity filter (better_profanity) replaces bad words with asterisks,
  then we strip those out entirely.

cluster_sentences():
  1. Encode all sentences into vectors using the sentence transformer
  2. Run K-Means clustering — an algorithm that groups similar vectors
     together. You tell it how many groups (clusters) you want, and it
     finds the best groupings.
  3. Return clusters sorted by size (biggest first), since larger clusters
     represent more common themes.

  K-Means works by:
  - Placing K random "center points" in the vector space
  - Assigning each sentence to its nearest center
  - Moving each center to the average of its assigned sentences
  - Repeating until the centers stop moving

  random_state=42 ensures reproducible results (same input → same clusters).
  n_init=10 means it runs the algorithm 10 times with different random
  starting points and picks the best result.

extract_cluster_topic():
  Uses TF-IDF (Term Frequency-Inverse Document Frequency) to find the
  distinctive keywords for each cluster.

  TF-IDF scores words by how important they are to a SPECIFIC document
  compared to ALL documents. A word that appears a lot in one cluster but
  rarely in others gets a high score. "soundtrack" might be common in one
  cluster and rare in others → high TF-IDF → it becomes a keyword.

  _STOP_WORDS filters out words too generic for game reviews ("game",
  "play", "really", etc.) that would otherwise dominate every cluster.

  ngram_range=(1, 2) means it considers both single words ("combat") and
  two-word phrases ("boss fights").


--- generator.py ---

generate_summary():
  Takes a cluster of similar sentences + their TF-IDF keywords and asks
  an LLM to write a short summary phrase.

  The prompt is carefully engineered:
  - "under 8 words" keeps it concise
  - "ONE phrase only" prevents lists
  - "Must name a specific game aspect" prevents vague output
  - "NEVER use vague phrases" blocks generic sentiments

  The model (arcee-ai/trinity-large-preview:free) is a free model on
  OpenRouter. OpenRouter is an API aggregator — one API key gives you
  access to models from many providers.

  temperature=0.3: Controls randomness. 0 = deterministic (always picks
  the most likely next word), 1 = very random. 0.3 is low, making output
  more focused and predictable.

  max_tokens=50: Maximum length of the response. We only want a short
  phrase, so 50 tokens (roughly 35 words) is plenty.

Post-processing cleanup:
  Even with a good prompt, LLMs don't always follow instructions perfectly.
  The cleanup code handles common failures:
  - Takes only the first line (model sometimes returns multiple lines)
  - Strips leading dashes/bullets (model sometimes adds "- " prefix)
  - Strips quotes (model sometimes wraps output in quotes)
  - Splits on " - " (model sometimes crams multiple items)

_is_vague():
  Catches summaries that are just generic sentiment without naming what's
  good/bad. "Can't recommend" tells you nothing. "Frustrating combat
  mechanics" tells you exactly what the problem is.

_wrong_sentiment():
  Catches polarity mismatches. Sometimes the LLM generates a negative
  phrase for a positive cluster (or vice versa). This checks for sentiment
  words and rejects mismatches. Example: "Alt-tabbing causes crashes"
  contains "crash" (negative signal) with no positive signals → rejected
  if it was supposed to be praise.


--- summarizer.py ---

The orchestrator. It doesn't do any ML or API calls itself — it just
coordinates the pipeline:

  1. extract_sentences() → clean, filter, get opinion sentences
  2. cluster_sentences() → group by semantic similarity
  3. extract_cluster_topic() → find each cluster's keywords via TF-IDF
  4. generate_summary() → ask LLM to write a phrase for each cluster

Scaling logic:
  - n_pos = max(5, min(8, len(pos_sentences) // 20))
    Cluster count scales with sentence volume. 100 sentences → 5 clusters.
    160+ sentences → 8 clusters. More clusters = more topics discovered.

  - max_points = 3 if < 30 sentences, 4 if 30-59, 5 if 60+
    Output bullet count also scales. A game with few reviews gets 3 points;
    a popular game with many reviews gets up to 5.

  The loop iterates through ALL clusters (not just max_points worth),
  because some summaries get filtered out by _is_vague() or
  _wrong_sentiment(). It stops once it has enough good ones.


================================================================================
FRONTEND
================================================================================

--- main.jsx ---

The entry point. React needs a real DOM element to "mount" onto.
createRoot(document.getElementById('root')) finds the <div id="root"> in
index.html and tells React to control it. StrictMode enables extra
development warnings (double-renders to catch bugs, etc.).


--- index.css ---

CSS custom properties (variables) defined on :root are accessible to every
element in the page. var(--steam-dark) anywhere in CSS resolves to #1b2838.
This is how the Steam theme stays consistent — change one variable and
every component updates.

The CSS reset (* { margin: 0; padding: 0; box-sizing: border-box }) removes
browser defaults so styling is consistent across Chrome, Firefox, Safari.
box-sizing: border-box makes width/height include padding and border,
which is far more intuitive than the default behavior.


--- App.jsx ---

React state (useState):
  const [loading, setLoading] = useState(false)
  Creates a variable (loading) and a setter (setLoading). When you call
  setLoading(true), React re-renders the component with the new value.
  This is React's core principle: state drives the UI.

Conditional rendering:
  {loading && <LoadingSpinner />}
  JavaScript short-circuit evaluation. If loading is false, the expression
  stops at "loading" and renders nothing. If true, it evaluates and renders
  <LoadingSpinner />. This is how React shows/hides components.

async/await:
  handleSearch is async because fetch() returns a Promise (a value that
  will arrive later). "await" pauses the function until the Promise resolves.
  The UI stays responsive during the wait because JavaScript is non-blocking.

fetch() gotcha:
  fetch() only throws on NETWORK errors (server unreachable). HTTP errors
  like 404 or 500 do NOT throw — you have to check response.ok manually.
  This is different from libraries like axios which throw on HTTP errors.

try/catch/finally:
  - try: the code that might fail
  - catch: runs if try threw an error
  - finally: ALWAYS runs, whether try succeeded or failed
  Perfect pattern for loading states: set loading=true before try, set
  loading=false in finally. The spinner always stops.


--- SearchBar.jsx ---

Controlled component:
  The input's value is controlled by React state (value={query}). Every
  keystroke fires onChange, which updates state, which updates the input.
  React is the "single source of truth" — the DOM input never has a value
  that React doesn't know about.

useEffect(fn, [deps]):
  Runs the function after render, but only when the dependencies change.
  - useEffect(fn, []) → runs once on mount (empty deps = no changes)
  - useEffect(fn, [query]) → runs whenever query changes

useRef:
  Creates a mutable reference that persists across renders WITHOUT causing
  re-renders when changed. Two uses here:
  1. debounceRef: holds a setTimeout ID so we can cancel pending timers
  2. wrapperRef: holds a reference to the DOM element for click-outside
     detection

Debouncing:
  Without debouncing, typing "skyrim" fires 6 API calls: "s", "sk", "sky",
  "skyr", "skyri", "skyrim". With debouncing, we wait 300ms after the last
  keystroke before firing. If the user types another character within 300ms,
  the timer resets. Result: usually just 1 API call.

  Implementation:
  1. User types → query changes → useEffect runs
  2. Clear any existing timer (clearTimeout)
  3. Set new timer for 300ms from now
  4. If user types again, step 2 cancels the timer before it fires
  5. After 300ms of silence, the fetch finally executes

Click-outside detection:
  We add a mousedown listener to the entire document. When a click happens,
  we check if the click target is inside our component using
  wrapperRef.current.contains(e.target). If not, close the dropdown.
  The cleanup function (return () => ...) removes the listener when the
  component unmounts, preventing memory leaks.


--- LoadingSpinner.jsx ---

A "presentational" component — no state, no logic, just JSX. The spinner
animation is pure CSS (no JavaScript needed).

aria-label="Loading" is an accessibility attribute. Screen readers announce
it for visually impaired users who can't see the spinning animation.


--- LoadingSpinner.css ---

The spinner trick:
  1. Create a 48x48 circle (border-radius: 50%)
  2. Give it a border where only the top is colored, rest transparent
  3. Rotate it 360 degrees with CSS @keyframes animation
  4. The colored arc sweeps around, creating the classic spinner look

@keyframes spin { to { transform: rotate(360deg); } }
  Defines an animation from 0deg (implicit start) to 360deg.

animation: spin 0.8s linear infinite;
  Apply the "spin" animation, 0.8 seconds per rotation, constant speed
  (linear), and repeat forever (infinite).


--- ResultDisplay.jsx ---

Props destructuring:
  function ResultDisplay({ game, appId, summary })
  Instead of receiving a single "props" object and accessing props.game,
  we destructure directly in the function signature. Cleaner code.

.map() for lists:
  summary.praised.map((point, index) => <li key={index}>...</li>)
  The standard React pattern for rendering arrays. React needs a unique
  "key" prop on each list item to efficiently track which items changed
  when the list updates.

Steam banner image:
  Every Steam game has a header image at a predictable URL:
  https://cdn.akamai.steamstatic.com/steam/apps/{app_id}/header.jpg
  No API call needed — just plug in the app ID. Always 460x215 pixels.

target="_blank" rel="noopener noreferrer":
  Opens links in a new tab. "noopener noreferrer" is a security measure
  that prevents the new page from accessing window.opener (which could
  be used for phishing attacks).


--- ResultDisplay.css ---

CSS Grid:
  grid-template-columns: 1fr 1fr creates two equal-width columns.
  "fr" = fraction of available space. 1fr 1fr = each gets half.
  Grid is ideal for 2D layouts (rows AND columns).

BEM modifiers:
  .result__section--positive and .result__section--negative extend the
  base .result__section class. The -- convention means "modifier" — a
  variation of the base style. Each just changes the border-top-color.

::before pseudo-element:
  .result__item::before creates a small circle (the custom bullet point)
  positioned absolutely inside each list item. content: '' is required
  for ::before to render anything.

@media (max-width: 640px):
  A responsive breakpoint. On screens narrower than 640px (phones), the
  two-column grid collapses to a single column.


--- SearchBar.css ---

position: relative on .search-bar creates a "positioning context." The
dropdown (position: absolute) then positions itself relative to this parent
instead of the entire page. top: 100% places it right below the parent.

z-index: 10 ensures the dropdown appears on top of any content below the
search bar. Without it, page content could overlap the dropdown.


================================================================================
KEY CONCEPTS SUMMARY
================================================================================

React:
  - Components are functions that return JSX (HTML-like syntax)
  - State (useState) drives the UI — change state, UI updates automatically
  - Props flow down from parent to child (like function arguments)
  - useEffect runs side effects (API calls, event listeners, timers)
  - useRef holds mutable values that persist across renders

CSS:
  - Custom properties (--var-name) for consistent theming
  - Flexbox for 1D layouts (row or column)
  - Grid for 2D layouts (rows and columns)
  - position: relative/absolute for overlays and dropdowns
  - @media queries for responsive design
  - BEM naming (.block__element--modifier) for organized CSS
  - ::before/::after pseudo-elements for decorative content

Python/FastAPI:
  - Decorators (@app.get) map URLs to functions
  - Query parameters are extracted from the URL automatically
  - CORS middleware enables cross-origin requests
  - Underscore prefix (_function) means "private, internal use only"

ML Pipeline:
  - Sentence embeddings convert text to vectors (numbers)
  - K-Means clustering groups similar vectors
  - TF-IDF finds distinctive keywords per cluster
  - LLM generates human-readable summaries from clusters
